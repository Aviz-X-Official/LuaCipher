using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

namespace RobloxExecutor
{
    class Program
    {
        [DllImport("kernel32")]
        static extern IntPtr GetConsoleWindow();

        [DllImport("user32")]
        static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        const int SW_HIDE = 0;
        const int SW_SHOW = 5;

        static void Main(string[] args)
        {

            IntPtr hWnd = GetConsoleWindow();
            ShowWindow(hWnd, SW_HIDE);

            Executor executor = new Executor();

            executor.Inject();

            ShowWindow(hWnd, SW_SHOW);

            while (true)
            {
                Console.Write(">> ");
                string command = Console.ReadLine();

                executor.Execute(command);
            }
        }
    }

    class Executor
    {
        [DllImport("kernel32")]
        static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, ref int lpNumberOfBytesWritten);

        [DllImport("kernel32")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32")]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, int flAllocationType, int flProtect);

        const int PROCESS_ALL_ACCESS = 0x1F0FFF;
        const int MEM_COMMIT = 0x1000;
        const int MEM_RESERVE = 0x2000;
        const int PAGE_EXECUTE_READWRITE = 0x40;

        IntPtr robloxProcess;
        IntPtr luaState;

        public void Inject()
        {

            Process[] processes = Process.GetProcessesByName("RobloxPlayerBeta");
            if (processes.Length == 0)
            {
                Console.WriteLine("Roblox is not running.");
                return;
            }

            robloxProcess = OpenProcess(PROCESS_ALL_ACCESS, false, processes[0].Id);

            luaState = FindLuaState(robloxProcess);

            IntPtr executorMemory = VirtualAllocEx(robloxProcess, IntPtr.Zero, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

            byte[] executorCode = Encoding.ASCII.GetBytes("local executor = {} function executor.execute(code) loadstring(code)() end");
            int bytesWritten;
            WriteProcessMemory(robloxProcess, executorMemory, executorCode, executorCode.Length, ref bytesWritten);

            IntPtr threadId;
            CreateRemoteThread(robloxProcess, IntPtr.Zero, 0, executorMemory, IntPtr.Zero, 0, ref threadId);

            IntPtr byfronBypassMemory = VirtualAllocEx(robloxProcess, IntPtr.Zero, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            byte[] byfronBypassCode = Encoding.ASCII.GetBytes("local byfron = require(game:GetService('HttpService'):GetAsync('https://byfron.com/api/v1/validate', true)) byfron.Validate = function() return true end");
            WriteProcessMemory(robloxProcess, byfronBypassMemory, byfronBypassCode, byfronBypassCode.Length, ref bytesWritten);
            CreateRemoteThread(robloxProcess, IntPtr.Zero, 0, byfronBypassMemory, IntPtr.Zero, 0, ref threadId);
        }

        public void Execute(string code)
        {

            IntPtr codeMemory = VirtualAllocEx(robloxProcess, IntPtr.Zero, code.Length + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

            byte[] codeBytes = Encoding.ASCII.GetBytes(code + "\0");
            int bytesWritten;
            WriteProcessMemory(robloxProcess, codeMemory, codeBytes, codeBytes.Length, ref bytesWritten);

            IntPtr executeAddress = luaState + 0x10; 
            CreateRemoteThread(robloxProcess, IntPtr.Zero, 0, executeAddress, codeMemory, 0, IntPtr.Zero);
        }

        IntPtr FindLuaState(IntPtr process)
        {

            IntPtr luaStateAddress = IntPtr.Zero;
            foreach (ProcessModule module in Process.GetProcessById(process.ToInt32()).Modules)
            {
                if (module.ModuleName == "lua51.dll")
                {
                    luaStateAddress = module.BaseAddress;
                    break;
                }
            }

            return luaStateAddress;
        }

        public void LoadUNCScript(string scriptPath)
        {

            string scriptCode = File.ReadAllText(scriptPath);

            Execute(scriptCode);
        }
    }
}
